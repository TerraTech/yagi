package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path"

	"github.com/hneemann/yagi/concrete"
	"github.com/hneemann/yagi/generify"
	"golang.org/x/tools/imports"
)

const MESSAGE = "// generated by yagi. Don't modify this file!\n// Any changes will be lost if this file is regenerated.\n\n"

func createOutName(out, tem string) string {
	if out != "" {
		return out
	} else {
		name := path.Base(tem)
		if name == tem {
			return "gen-" + name
		} else {
			return name
		}
	}
}

func main() {
	tem := flag.String("tem", "", "name of the template go file")
	out := flag.String("out", "", "name of the new source file")
	pgk := flag.String("pkg", "", "name of the package")
	gen := flag.String("gen", "", "concrete types e.g string,int;string,double64")
	imp := flag.Bool("imp", true, "run go imports")
	flag.Parse()

	// read the source file
	fset := token.NewFileSet()
	ast, err := parser.ParseFile(fset, *tem, nil, parser.ParseComments)
	if err != nil {
		fmt.Println("reading source file: ", err)
		return
	}

	// prepeare the concrete types
	c, err := concrete.New(*gen)
	if err != nil {
		fmt.Println("processing concrete types: ", err)
		return
	}

	// generify the source file
	gener := generify.New(ast, c)
	var buffer = new(bytes.Buffer)
	buffer.WriteString(MESSAGE)
	err = gener.Do(*pgk, buffer)
	if err != nil {
		fmt.Println("creating code: ", err)
		return
	}

	var output []byte
	if *imp {
		// run go imports
		output, err = imports.Process("", buffer.Bytes(), nil)
		if err != nil {
			fmt.Println("go imports: ", err)
			return
		}
	} else {
		output = buffer.Bytes()
	}

	// write the output
	outName := createOutName(*out, *tem)
	file, err := os.Create(outName)
	if err != nil {
		fmt.Println("create output file: ", err)
		return
	}
	defer file.Close()

	_, err = file.Write(output)
	if err != nil {
		fmt.Println("write output file: ", err)
	}
}
